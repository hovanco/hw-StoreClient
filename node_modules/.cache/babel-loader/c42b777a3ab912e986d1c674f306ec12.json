{"ast":null,"code":"import axios from 'axios';\nimport queryString from 'query-string';\nimport constants from '../constants';\nimport authTypes from '../reducers/authState/authTypes';\nimport store from '../store';\nimport authApi from './auth-api';\nimport { checkToken, getToken, getTokenLocal, removeToken, setToken } from './token';\nlet isRefreshed = false;\nconst axiosClient = axios.create({\n  baseURL: constants.URL_API,\n  headers: {\n    'content-type': 'application/json'\n  },\n  paramsSerializer: params => queryString.stringify(params)\n});\naxiosClient.interceptors.request.use(config => {\n  const accessToken = getToken('accessToken');\n\n  if (accessToken) {\n    config.headers['Authorization'] = 'Bearer ' + accessToken;\n  }\n\n  return config;\n});\naxiosClient.interceptors.response.use(response => {\n  return response;\n}, async error => {\n  const originalRequest = error.config;\n\n  if (error.response.status === 401 && !isRefreshed) {\n    isRefreshed = true;\n    const refreshToken = getToken('refreshToken');\n\n    if (refreshToken) {\n      const isValidRefreshToken = checkToken(refreshToken);\n\n      if (!isValidRefreshToken) {\n        return Promise.reject(error);\n      }\n\n      try {\n        const response = await authApi.refreshAccessToken(refreshToken);\n        const tokenLocal = getTokenLocal();\n        const {\n          accessToken\n        } = response;\n        setToken({\n          token: { ...tokenLocal,\n            accessToken\n          },\n          remember: true\n        });\n        store.dispatch({\n          type: authTypes.UPDATE_TOKEN,\n          payload: {\n            accessToken,\n            type: 'Bearer'\n          }\n        });\n        originalRequest._retry = true;\n        axios.defaults.headers.common['Authorization'] = `Bearer ${accessToken}`;\n        return axiosClient(originalRequest);\n      } catch (err) {\n        if (err.response.status === 401) {\n          if (refreshToken) {\n            await authApi.logout(refreshToken);\n          }\n\n          removeToken();\n        }\n\n        return Promise.reject(err);\n      }\n    }\n\n    return Promise.reject(error);\n  }\n\n  return Promise.reject(error);\n});\nexport default axiosClient;","map":{"version":3,"sources":["/Users/mac3/Desktop/workspace/StoreClient/src/api/axios-client.ts"],"names":["axios","queryString","constants","authTypes","store","authApi","checkToken","getToken","getTokenLocal","removeToken","setToken","isRefreshed","axiosClient","create","baseURL","URL_API","headers","paramsSerializer","params","stringify","interceptors","request","use","config","accessToken","response","error","originalRequest","status","refreshToken","isValidRefreshToken","Promise","reject","refreshAccessToken","tokenLocal","token","remember","dispatch","type","UPDATE_TOKEN","payload","_retry","defaults","common","err","logout"],"mappings":"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","sourcesContent":["import axios from 'axios';\nimport queryString from 'query-string';\nimport { IToken } from '../components/refresh-token/token';\nimport constants from '../constants';\nimport authTypes from '../reducers/authState/authTypes';\nimport store from '../store';\nimport authApi from './auth-api';\nimport { checkToken, getToken, getTokenLocal, removeToken, setToken } from './token';\n\nlet isRefreshed = false;\n\nconst axiosClient = axios.create({\n    baseURL: constants.URL_API,\n    headers: {\n        'content-type': 'application/json',\n    },\n    paramsSerializer: (params) => queryString.stringify(params),\n});\n\naxiosClient.interceptors.request.use((config) => {\n    const accessToken = getToken('accessToken');\n\n    if (accessToken) {\n        config.headers['Authorization'] = 'Bearer ' + accessToken;\n    }\n    return config;\n});\n\naxiosClient.interceptors.response.use(\n    (response) => {\n        return response;\n    },\n\n    async (error) => {\n        const originalRequest = error.config;\n\n        if (error.response.status === 401 && !isRefreshed) {\n            isRefreshed = true;\n\n            const refreshToken = getToken('refreshToken');\n\n            if (refreshToken) {\n                const isValidRefreshToken = checkToken(refreshToken);\n\n                if (!isValidRefreshToken) {\n                    return Promise.reject(error);\n                }\n\n                try {\n                    const response = await authApi.refreshAccessToken(refreshToken);\n                    const tokenLocal = getTokenLocal();\n                    const { accessToken } = response;\n\n                    setToken({\n                        token: {\n                            ...(tokenLocal as IToken),\n                            accessToken,\n                        },\n                        remember: true,\n                    });\n\n                    store.dispatch({\n                        type: authTypes.UPDATE_TOKEN,\n                        payload: {\n                            accessToken,\n                            type: 'Bearer',\n                        },\n                    });\n\n                    originalRequest._retry = true;\n                    axios.defaults.headers.common['Authorization'] = `Bearer ${accessToken}`;\n\n                    return axiosClient(originalRequest);\n                } catch (err) {\n                    if (err.response.status === 401) {\n                        if (refreshToken) {\n                            await authApi.logout(refreshToken);\n                        }\n\n                        removeToken();\n                    }\n\n                    return Promise.reject(err);\n                }\n            }\n\n            return Promise.reject(error);\n        }\n\n        return Promise.reject(error);\n    },\n);\n\nexport default axiosClient;\n"]},"metadata":{},"sourceType":"module"}